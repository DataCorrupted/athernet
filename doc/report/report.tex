%% Computer Networks Project Report Latex file.
%% Completed By Yuyang Rong(rongyy@shanghaitech.edu.cn) and 
%% Jianxiong Cai(caijx@shanghaitech.edu.cn)
%%
%% To edit this file, please use indentions with tab size of 2.
%%

\documentclass[conference,compsoc]{IEEEtran}
\usepackage{cite}
\usepackage{listings}
\usepackage{mathtools}
\usepackage{amsmath,amsthm,amssymb,amsfonts}
\usepackage{array}

\lstset{
	basicstyle=\small\ttfamily,
	columns=fullflexible,
	tabsize=1
}
\begin{document}
\title{
	Computer Networks Course Report
}
% author names and affiliations
% use a multiple column layout for up to three different
% affiliations
\author{
	\IEEEauthorblockN{Yuyang Rong}
	\IEEEauthorblockA{
		School of Information Science and Technology \\
		ShanghaiTech University \\
		Student ID: 69850764 \\
	}
\and
	\IEEEauthorblockN{Jianxiong Cai}
	\IEEEauthorblockA{
		School of Information Science and Technology \\
		ShanghaiTech University \\
		Student ID: 67771603 \\
	}
}

\maketitle

% As a general rule, do not put math, special symbols or citations
% in the abstract
\begin{abstract}
A quick brown fox jumps over a lazy dog.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Project 1: physical layer
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project 1: physical layer}
	
	%TODO
	\subsection{Sound card and DataLine}
		A quick brown fox jumps over a lazy dog.
	
	%TODO
	\subsection{Java experience: OOP}
		A quick brown fox jumps over a lazy dog.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Project 2: mac layer
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project 2: mac layer}
	
	%TOCHECK
	\subsection{Mac Packet}
		The basic unit in mac layer is a new type of packet called \lstinline{MacPacket}. It contains all the data, the type of this packet, it's current status and the time it's been sent. The Mac address of the sender and the received will also be stored.
		\subsubsection{Conversion between byte array and MacPacket}
			We have to examine the definition of the byte array first. It is show in the table \ref{MacPacket_dataDef}
			\begin{table}[h]
			\begin{tabular}{m{0.5cm}m{2cm}m{0.5cm}m{0.5cm}m{1cm}m{1cm}}\label{MacPacket_dataDef}
				Offset                        & 0                       & 8                        & 10                       & 12                        & 16                        \\ \hline
				\multicolumn{1}{|l|}{Content} & \multicolumn{1}{l|}{ID} & \multicolumn{1}{l|}{src} & \multicolumn{1}{l|}{dst} & \multicolumn{1}{l|}{type} & \multicolumn{1}{l|}{data} \\ \hline
			\end{tabular}
			\caption{The definition of a MacPacket}
			\end{table}
			\par
			To convert a MacPacket to byte array is somewhat simple, just use \lstinline{System.arraycopy(...)} is good. But to convert a byte array to \lstinline{MacPacket}, we need to carefully take the bits out by using shift.

	\subsection{Request}
		We can not allow packet to be send directly. To send a packet, the user has to call \lstinline{MacLayer.requestSend(...)} and then the mac layer can begin to process. 
		As a matter of fact, user can not call \lstinline{MacLayer.send()} directly as it's a private function.
		\par
		The parameters in the function above varies. We provided a lot of interface so that it is handy in use. You can use an instance of \lstinline{MacPacket} to request send. 
		\begin{lstlisting}[linewidth=\columnwidth,language=Java]
			MacLayer.requestSend(MacPacket);
		\end{lstlisting}
		\par
		Other methods to request a send service is to give a raw byte array if it is a data packet or just state the length of the incoming data if it is a control packet at the head of every data stream.
		\begin{lstlisting}[linewidth=\columnwidth,language=Java]
			MacLayer.requestSend(byte[] raw_data);
			MacLayer.requestSend(int data_len);
		\end{lstlisting}
		In these two function, we will pack the data into a \lstinline{MacPacket} and call \lstinline{MacLayer.requestSend(MacPacket)}
		\par
		Once a packet is requested to be sent, first thing we do in \lstinline{MacLayer.requestSend(MacPacket)} is assign this packet an id. 
		Packet ID is the identifier to guarantee that we don't receive the same packet.
		(This is possible when the ACK we replied is lost.)
		With id setup, we will put the packet in the waiting queue. We will determine whether it's a priority one(mainly ACK packet, we added another priority packet MACPING in project 3) or not. 
		Priority packet will be placed at the head of the waiting queue so that it can be sent first, other packets will be placed at the tail of the queue and follow FIFO. 
		\par
		We may have a design flaw here. 
		The fact that we reply ACK first may lead to normal data being chocked if we are receiving enormous packets and busy replying ACKs.
	\subsection{Send}
		\lstinline{MacLayer.send()} is a loop that only stops upon user's call.
		In each iteration, it will take the a window of the waiting queue. For each packet in the window, our action depends on the label of the packet.
		\par
		If the label is \lstinline{MacPacket.STATUS_WAITING}, it will be converted to raw \lstinline{byte[]} and send it by calling \lstinline{Transmitter.transmitOnePack(byte[] data)}. The status of the packet will be labeled \lstinline{MacPacket.STATUS_ACKED} if this packet need no ACK(for example, ACK packet need no ACK, or it would be infinity of ACKs wondering in the channel busying ACK each other.). Packets that needs to be ACKed will be labeled \lstinline{MacPacket.STATUS_SENT}.
		\par 
		If the label is \lstinline{MacPacket.STATUS_SENT}. 
		We will examine the time stamp in the packet and compare with the current to determine if the packet has time out. Upon timeout, we change the label to \lstinline{MacPacket.STATUS_WAITING} so that it can be resent. 
		We will also add the counter inside the packet so that we know how many time it has been resent. 
		If we have resend it too much, we will report a link error.
		\par
		When one window's packet have been processed, we will run a second pass on that window and re-examine the labels. 
		This time we are looking for \lstinline{MacPacket.STATUS_ACKED}. 
		We moves the window foreword if the head of the waiting queue has been ACKed. 
		Also, we will take back the id of that ACKed packet so that late comers can re-use the id.

	%TOCHECK
	\subsubsection{Receive}
		\lstinline{MacLayer.receive()} is also a function that loops until the user stops it.
		\par
		At each iteration, it will try to receive a frame by calling \lstinline{Receiver.receiveOnePack()}.
		The function may fail as there is nothing to be received and return an empty array, then the iteration ends and goes to next iteration.
		Correct frame can be received, then we will transform the received \lstinline{byte[]} to \lstinline{MacPacket} without certain informations like time stamp, but that will not hurt.
		With an instance of \lstinline{MacPacket} we will check the mac address of the packet. 
		If the address is not correct, we will start the next iteration. 
		We will send an ACK if this is a data packet and put it into data buffer. 
		If the packet is and ACK packet, we will check the find the packet that is being ACKed and change it's label to \lstinline{MacPacket.STATUS_ACKED}.
		A patch we added for MACPING is to either reply that MACPING or calculate the time eclipsed.

	%TOCHECK
	\subsection{Thread pool}\label{Thread pool}
		\lstinline{MacLayer.send()} and \lstinline{MacLayer.receive()} should be in two threads. We set up two threads. 
		The user has to call \lstinline{MacLayer.startMacLayer()} to start them and use \lstinline{MacLayer.stopMacLayer} to stop the threads.
	
	%TODO
	\subsection{Sequential arriving data}
	
	%TOCHECK
	\subsection{Signal Detection}
		Whenever sending a frame, the sender must make sure that the channel is clean and is good for transmission.
		The process is somewhat similar to CSMA/CD, yet there is no detecting while sending.
		\par
		The sending process will start only when the moving average power of the channel is low enough. The avg power should satisfy:
		\begin{equation}\begin{aligned}
		avg_k \\
		& = 
			\frac{win\_size-1}{win\_size}avg_{k-1} + 
			\frac{1}{win\_size} * power_k \\
		& > thr
		\end{aligned}\end{equation}
		where in our implementation, we have:
		\begin{equation*}\begin{aligned} 
			& win\_size = 24 \\
			& thr = 0.3 
		\end{aligned}\end{equation*}
		\par
		If the power is	greater than the threshold we set, we will wait sometime, by default we wait 10ms.
		\par 
		We didn't add collection detection in out implemtation due to one design flaw. We split the physical layer to two independent part: sender and receiver. The fact that these two components cannot communate leads to the hardship when writing collection detection. We hold one assumption while doing this project, that once the transmittion is started, no one will interupted because other senders should be listening the channel and hold off sending only when the average power goes down.
	%TODO
	\subsection{Java experience: reference}
		Peter please fill this part.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Project 3: gateway
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project 3: gateway}

%TODO: insert a graph to illistrate the overall layout in this part
	
	%TODO
	\subsection{JNI}
		Peter please fill this part.
	
	%TODO
	\subsection{Pipe}
		Peter please fill this part.
		
		%TODO: maybe nat_pack should be mentioned here? 
	
	%TODO
	\subsection{C++ experience: Socket Programming}
		\paragraph{\textbf{gateway on the c++ side}}
		The c++ need to handle all Internet Communication and provide I/O service for the java gateway agent. In other words, the c++ gateway need to send out IP packets whenever the java gateway request sending, and give received packet from Internet to Java Interface (with some pre-pocessing).
		
		
		\paragraph{\textbf{TCP, UDP and ICMP}}
		For TCP and UDP, we are calling the interfaces provided by linux keneral interface, inlcuding \emph{socket}, \emph{binding}, \emph{connect}, \emph{sendto} and \emph{recefrom}. For ICMP, we are using the ICMP provided by Boost Libraries. 
		\paragraph{\textbf{TCP Receiving Buffer}}
		 One tricky part here is that TCP is streaming rather than transmitting packets, which results in that one frame may split into two frames when sending out. In order to solve the problem, for some application scenarioes, we use first several bytes to encode the length of the frame on sending and receiver store the current frame to buffer if it need to wait for the next frame.
		

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Project 4: FTP application
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Project 4: FTP application}
	\subsection{Overview}	
	The FTP connection is handled mainly at the gateway side. The node A (athernet FTP client) is connected to node B through athernet. The node B (FTP gateway) is connected to FTP Server via Internet.
	\subsection{Passive Mode}
	For \emph{LIST} and \emph{RETR} command, passive mode need to be supported. The gateway parses every reply from FTP server before redirecting that to java client. Once the gateway received a reply starting with code 227, the reply from server with expected passive ports, the gateway records it as \emph{data\_port}. Then, if the gateway received a sending request of \emph{LIST} or \emph{RETR}, it immediately start a new TCP connection to the server with \emph{data\_port}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Course and Homework
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Course \& Homework}
	
	%TODO
	\subsection{Course}
	
	%TODO
	\subsection{Homework}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%
%% Acknowledgement
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section*{Acknowledgment}
	%TODO

\bibliographystyle{IEEEtran}
\bibliography{report}


% that's all folks
\end{document}


